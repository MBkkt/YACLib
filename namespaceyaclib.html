<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YACLib: yaclib Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">YACLib
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">C++ library for concurrent tasks execution</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceyaclib.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">yaclib Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceyaclib_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceyaclib_1_1util"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib_1_1util.html">util</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1WaitGroup.html">WaitGroup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1Future.html">Future</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a mechanism to access the result of async operations.  <a href="classyaclib_1_1Future.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1Promise.html">Promise</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyaclib_1_1Contract.html">Contract</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes channel with future and promise.  <a href="structyaclib_1_1Contract.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1IExecutor.html">IExecutor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1ITask.html">ITask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callable that can be executed in an <a class="el" href="classyaclib_1_1IExecutor.html">IExecutor</a>.  <a href="classyaclib_1_1ITask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1IThread.html">IThread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1IThreadFactory.html">IThreadFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1IThreadPool.html">IThreadPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classInterface.html">Interface</a> for thread-pool-like executors.  <a href="classyaclib_1_1IThreadPool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1Inline.html">Inline</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7231c27a288094bf6017cda8cb4e2f7a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a7231c27a288094bf6017cda8cb4e2f7a">IExecutorPtr</a> = <a class="el" href="classyaclib_1_1util_1_1Ptr.html">util::Ptr</a>&lt; <a class="el" href="classyaclib_1_1IExecutor.html">IExecutor</a> &gt;</td></tr>
<tr class="separator:a7231c27a288094bf6017cda8cb4e2f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c3cb3b321f85b6e96b47e50f6e0b0d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a85c3cb3b321f85b6e96b47e50f6e0b0d">IThreadPtr</a> = <a class="el" href="classyaclib_1_1IThread.html">IThread</a> *</td></tr>
<tr class="separator:a85c3cb3b321f85b6e96b47e50f6e0b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af9e084c41dda4eb49c4f7d96b96fdd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a2af9e084c41dda4eb49c4f7d96b96fdd">IThreadFactoryPtr</a> = <a class="el" href="classyaclib_1_1util_1_1Ptr.html">util::Ptr</a>&lt; <a class="el" href="classyaclib_1_1IThreadFactory.html">IThreadFactory</a> &gt;</td></tr>
<tr class="separator:a2af9e084c41dda4eb49c4f7d96b96fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c53b61d7ba175a9a056a249735148f5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a1c53b61d7ba175a9a056a249735148f5">IThreadPoolPtr</a> = <a class="el" href="classyaclib_1_1util_1_1Ptr.html">util::Ptr</a>&lt; <a class="el" href="classyaclib_1_1IThreadPool.html">IThreadPool</a> &gt;</td></tr>
<tr class="separator:a1c53b61d7ba175a9a056a249735148f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a37f2112670e904598949ee2d6f043254"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a37f2112670e904598949ee2d6f043254">PolicyWhenAny</a> { <a class="el" href="namespaceyaclib.html#a37f2112670e904598949ee2d6f043254a928e284a9dd5356bc1ca5f82a38e47d9">FirstError</a>
, <a class="el" href="namespaceyaclib.html#a37f2112670e904598949ee2d6f043254a49b8f9d972a16a3efaab2442f79bcacb">LastError</a>
 }</td></tr>
<tr class="separator:a37f2112670e904598949ee2d6f043254"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a37a6bb22f7fab7bbca62739964ed895d"><td class="memTemplParams" colspan="2">template&lt;typename... Futures&gt; </td></tr>
<tr class="memitem:a37a6bb22f7fab7bbca62739964ed895d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a37a6bb22f7fab7bbca62739964ed895d">Wait</a> (Futures &amp;&amp;... fs)</td></tr>
<tr class="memdesc:a37a6bb22f7fab7bbca62739964ed895d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until Ready becomes true.  <a href="namespaceyaclib.html#a37a6bb22f7fab7bbca62739964ed895d">More...</a><br /></td></tr>
<tr class="separator:a37a6bb22f7fab7bbca62739964ed895d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6a79b363eabace9eaa99eb665f4fc1"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period , typename... Futures&gt; </td></tr>
<tr class="memitem:a3a6a79b363eabace9eaa99eb665f4fc1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a3a6a79b363eabace9eaa99eb665f4fc1">WaitFor</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;timeout_duration, Futures &amp;&amp;... fs)</td></tr>
<tr class="memdesc:a3a6a79b363eabace9eaa99eb665f4fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the specified timeout duration has elapsed or Ready becomes true.  <a href="namespaceyaclib.html#a3a6a79b363eabace9eaa99eb665f4fc1">More...</a><br /></td></tr>
<tr class="separator:a3a6a79b363eabace9eaa99eb665f4fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93d083816b0da430408ad4ff34d55a4"><td class="memTemplParams" colspan="2">template&lt;typename Clock , typename Duration , typename... Futures&gt; </td></tr>
<tr class="memitem:ab93d083816b0da430408ad4ff34d55a4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ab93d083816b0da430408ad4ff34d55a4">WaitUntil</a> (const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout_time, Futures &amp;&amp;... fs)</td></tr>
<tr class="memdesc:ab93d083816b0da430408ad4ff34d55a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until specified time has been reached or Ready becomes true.  <a href="namespaceyaclib.html#ab93d083816b0da430408ad4ff34d55a4">More...</a><br /></td></tr>
<tr class="separator:ab93d083816b0da430408ad4ff34d55a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d49a2608a8a33787c5a3cea5e48faa9"><td class="memTemplParams" colspan="2">template&lt;typename It , typename T  = util::detail::FutureValueT&lt;typename std::iterator_traits&lt;It&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:a3d49a2608a8a33787c5a3cea5e48faa9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a3d49a2608a8a33787c5a3cea5e48faa9">WhenAll</a> (It begin, size_t size)</td></tr>
<tr class="memdesc:a3d49a2608a8a33787c5a3cea5e48faa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classyaclib_1_1Future.html">Future</a> which will be ready when all futures are ready.  <a href="namespaceyaclib.html#a3d49a2608a8a33787c5a3cea5e48faa9">More...</a><br /></td></tr>
<tr class="separator:a3d49a2608a8a33787c5a3cea5e48faa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05755a6f4937c6e11bcf41e962efe76"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:ab05755a6f4937c6e11bcf41e962efe76"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ab05755a6f4937c6e11bcf41e962efe76">WhenAll</a> (It begin, It end)</td></tr>
<tr class="memdesc:ab05755a6f4937c6e11bcf41e962efe76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classyaclib_1_1Future.html">Future</a> which will be ready when all futures are ready.  <a href="namespaceyaclib.html#ab05755a6f4937c6e11bcf41e962efe76">More...</a><br /></td></tr>
<tr class="separator:ab05755a6f4937c6e11bcf41e962efe76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5e7b2d43671c14b7be0241a13d358f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Fs&gt; </td></tr>
<tr class="memitem:a0d5e7b2d43671c14b7be0241a13d358f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a0d5e7b2d43671c14b7be0241a13d358f">WhenAll</a> (<a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; T &gt; &amp;&amp;head, Fs &amp;&amp;... tail)</td></tr>
<tr class="memdesc:a0d5e7b2d43671c14b7be0241a13d358f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classyaclib_1_1Future.html">Future</a> which will be ready when all futures are ready.  <a href="namespaceyaclib.html#a0d5e7b2d43671c14b7be0241a13d358f">More...</a><br /></td></tr>
<tr class="separator:a0d5e7b2d43671c14b7be0241a13d358f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefa36ba9f61dcc44b7b4b7b9b137eb7"><td class="memTemplParams" colspan="2">template&lt;PolicyWhenAny P = PolicyWhenAny::FirstError, typename It , typename T  = util::detail::FutureValueT&lt;typename std::iterator_traits&lt;It&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:aeefa36ba9f61dcc44b7b4b7b9b137eb7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#aeefa36ba9f61dcc44b7b4b7b9b137eb7">WhenAny</a> (It begin, size_t size)</td></tr>
<tr class="memdesc:aeefa36ba9f61dcc44b7b4b7b9b137eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classyaclib_1_1Future.html">Future</a> that is ready when any of futures is ready.  <a href="namespaceyaclib.html#aeefa36ba9f61dcc44b7b4b7b9b137eb7">More...</a><br /></td></tr>
<tr class="separator:aeefa36ba9f61dcc44b7b4b7b9b137eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8888500725b47abf63d9a187311e5501"><td class="memTemplParams" colspan="2">template&lt;PolicyWhenAny P = PolicyWhenAny::FirstError, typename It , typename T  = util::detail::FutureValueT&lt;typename std::iterator_traits&lt;It&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:a8888500725b47abf63d9a187311e5501"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a8888500725b47abf63d9a187311e5501">WhenAny</a> (It begin, It end)</td></tr>
<tr class="memdesc:a8888500725b47abf63d9a187311e5501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classyaclib_1_1Future.html">Future</a> that is ready when any of futures is ready.  <a href="namespaceyaclib.html#a8888500725b47abf63d9a187311e5501">More...</a><br /></td></tr>
<tr class="separator:a8888500725b47abf63d9a187311e5501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5363dd6455722e183c0ef83bc706b6"><td class="memTemplParams" colspan="2">template&lt;PolicyWhenAny P = PolicyWhenAny::FirstError, typename T , typename... Fs&gt; </td></tr>
<tr class="memitem:a7b5363dd6455722e183c0ef83bc706b6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a7b5363dd6455722e183c0ef83bc706b6">WhenAny</a> (<a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; T &gt; &amp;&amp;head, Fs &amp;&amp;... tail)</td></tr>
<tr class="memdesc:a7b5363dd6455722e183c0ef83bc706b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classyaclib_1_1Future.html">Future</a> that is ready when any of futures is ready.  <a href="namespaceyaclib.html#a7b5363dd6455722e183c0ef83bc706b6">More...</a><br /></td></tr>
<tr class="separator:a7b5363dd6455722e183c0ef83bc706b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de6f83d739994cdb2ab9348060ccfe0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9de6f83d739994cdb2ab9348060ccfe0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structyaclib_1_1Contract.html">Contract</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a9de6f83d739994cdb2ab9348060ccfe0">MakeContract</a> ()</td></tr>
<tr class="memdesc:a9de6f83d739994cdb2ab9348060ccfe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates related future and promise.  <a href="namespaceyaclib.html#a9de6f83d739994cdb2ab9348060ccfe0">More...</a><br /></td></tr>
<tr class="separator:a9de6f83d739994cdb2ab9348060ccfe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57cab962d5a434a0e5bb954b4dc06b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#af57cab962d5a434a0e5bb954b4dc06b7">MakeFuture</a> ()</td></tr>
<tr class="separator:af57cab962d5a434a0e5bb954b4dc06b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6a352774c58d4aab80fdb73961c00e"><td class="memTemplParams" colspan="2">template&lt;typename V , typename T  = std::remove_reference_t&lt;V&gt;&gt; </td></tr>
<tr class="memitem:afd6a352774c58d4aab80fdb73961c00e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#afd6a352774c58d4aab80fdb73961c00e">MakeFuture</a> (V &amp;&amp;value)</td></tr>
<tr class="separator:afd6a352774c58d4aab80fdb73961c00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc0efb205f36bd5fd244f1991658c0b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:abbc0efb205f36bd5fd244f1991658c0b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_same_v&lt; T, std::remove_reference_t&lt; V &gt; &gt;, <a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#abbc0efb205f36bd5fd244f1991658c0b">MakeFuture</a> (V &amp;&amp;value)</td></tr>
<tr class="separator:abbc0efb205f36bd5fd244f1991658c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbf001b64fb8536699a934ef2da6706"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a5fbf001b64fb8536699a934ef2da6706"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a5fbf001b64fb8536699a934ef2da6706">Run</a> (const <a class="el" href="namespaceyaclib.html#a7231c27a288094bf6017cda8cb4e2f7a">IExecutorPtr</a> &amp;e, Functor &amp;&amp;f)</td></tr>
<tr class="memdesc:a5fbf001b64fb8536699a934ef2da6706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute Callable functor via executor.  <a href="namespaceyaclib.html#a5fbf001b64fb8536699a934ef2da6706">More...</a><br /></td></tr>
<tr class="separator:a5fbf001b64fb8536699a934ef2da6706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab247a06a303af6a2234d2247eb0d1e55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyaclib.html#a7231c27a288094bf6017cda8cb4e2f7a">IExecutorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ab247a06a303af6a2234d2247eb0d1e55">MakeInline</a> () noexcept</td></tr>
<tr class="memdesc:ab247a06a303af6a2234d2247eb0d1e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="classyaclib_1_1Inline.html">Inline</a> executor singleton object.  <a href="namespaceyaclib.html#ab247a06a303af6a2234d2247eb0d1e55">More...</a><br /></td></tr>
<tr class="separator:ab247a06a303af6a2234d2247eb0d1e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd98a07638a00a30d55a2bd8527f197"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyaclib.html#a7231c27a288094bf6017cda8cb4e2f7a">IExecutorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#addd98a07638a00a30d55a2bd8527f197">MakeSerial</a> (<a class="el" href="namespaceyaclib.html#a7231c27a288094bf6017cda8cb4e2f7a">IExecutorPtr</a> e)</td></tr>
<tr class="memdesc:addd98a07638a00a30d55a2bd8527f197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serial is the asynchronous analogue of a mutex.  <a href="namespaceyaclib.html#addd98a07638a00a30d55a2bd8527f197">More...</a><br /></td></tr>
<tr class="separator:addd98a07638a00a30d55a2bd8527f197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac43f3130e0930be550b31fccdb5f72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyaclib.html#a2af9e084c41dda4eb49c4f7d96b96fdd">IThreadFactoryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#acac43f3130e0930be550b31fccdb5f72">MakeThreadFactory</a> (size_t cache=0)</td></tr>
<tr class="separator:acac43f3130e0930be550b31fccdb5f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79929f0e9d8377b4491a430042fcd808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyaclib.html#a2af9e084c41dda4eb49c4f7d96b96fdd">IThreadFactoryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a79929f0e9d8377b4491a430042fcd808">MakeThreadFactory</a> (<a class="el" href="namespaceyaclib.html#a2af9e084c41dda4eb49c4f7d96b96fdd">IThreadFactoryPtr</a> base, std::string name)</td></tr>
<tr class="separator:a79929f0e9d8377b4491a430042fcd808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34239f1ca3ed395ed5d22993d751c96a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyaclib.html#a2af9e084c41dda4eb49c4f7d96b96fdd">IThreadFactoryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a34239f1ca3ed395ed5d22993d751c96a">MakeThreadFactory</a> (<a class="el" href="namespaceyaclib.html#a2af9e084c41dda4eb49c4f7d96b96fdd">IThreadFactoryPtr</a> base, size_t priority)</td></tr>
<tr class="separator:a34239f1ca3ed395ed5d22993d751c96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9f5858b675d032b6d23b156f9769d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyaclib.html#a2af9e084c41dda4eb49c4f7d96b96fdd">IThreadFactoryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#aac9f5858b675d032b6d23b156f9769d3">MakeThreadFactory</a> (<a class="el" href="namespaceyaclib.html#a2af9e084c41dda4eb49c4f7d96b96fdd">IThreadFactoryPtr</a> base, <a class="el" href="namespaceyaclib_1_1util.html#ae7fef7e414f78f74b8ab2cf37069dee0">util::IFuncPtr</a> acquire, <a class="el" href="namespaceyaclib_1_1util.html#ae7fef7e414f78f74b8ab2cf37069dee0">util::IFuncPtr</a> release)</td></tr>
<tr class="separator:aac9f5858b675d032b6d23b156f9769d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e27483f912682aad998898f42b775f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyaclib_1_1IThreadPool.html">IThreadPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a60e27483f912682aad998898f42b775f">CurrentThreadPool</a> () noexcept</td></tr>
<tr class="separator:a60e27483f912682aad998898f42b775f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f76f7768e2f42ea4d8cc13180a62f0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyaclib.html#a1c53b61d7ba175a9a056a249735148f5">IThreadPoolPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a9f76f7768e2f42ea4d8cc13180a62f0c">MakeThreadPool</a> (size_t threads=std::thread::hardware_concurrency(), <a class="el" href="namespaceyaclib.html#a2af9e084c41dda4eb49c4f7d96b96fdd">IThreadFactoryPtr</a> tf=<a class="el" href="namespaceyaclib.html#acac43f3130e0930be550b31fccdb5f72">MakeThreadFactory</a>())</td></tr>
<tr class="memdesc:a9f76f7768e2f42ea4d8cc13180a62f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new ThreadPool object.  <a href="namespaceyaclib.html#a9f76f7768e2f42ea4d8cc13180a62f0c">More...</a><br /></td></tr>
<tr class="separator:a9f76f7768e2f42ea4d8cc13180a62f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a7231c27a288094bf6017cda8cb4e2f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7231c27a288094bf6017cda8cb4e2f7a">&#9670;&nbsp;</a></span>IExecutorPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#a7231c27a288094bf6017cda8cb4e2f7a">yaclib::IExecutorPtr</a> = typedef <a class="el" href="classyaclib_1_1util_1_1Ptr.html">util::Ptr</a>&lt;<a class="el" href="classyaclib_1_1IExecutor.html">IExecutor</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="executor_8hpp_source.html#l00053">53</a> of file <a class="el" href="executor_8hpp_source.html">executor.hpp</a>.</p>

</div>
</div>
<a id="a2af9e084c41dda4eb49c4f7d96b96fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af9e084c41dda4eb49c4f7d96b96fdd">&#9670;&nbsp;</a></span>IThreadFactoryPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#a2af9e084c41dda4eb49c4f7d96b96fdd">yaclib::IThreadFactoryPtr</a> = typedef <a class="el" href="classyaclib_1_1util_1_1Ptr.html">util::Ptr</a>&lt;<a class="el" href="classyaclib_1_1IThreadFactory.html">IThreadFactory</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__factory_8hpp_source.html#l00025">25</a> of file <a class="el" href="thread__factory_8hpp_source.html">thread_factory.hpp</a>.</p>

</div>
</div>
<a id="a1c53b61d7ba175a9a056a249735148f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c53b61d7ba175a9a056a249735148f5">&#9670;&nbsp;</a></span>IThreadPoolPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#a1c53b61d7ba175a9a056a249735148f5">yaclib::IThreadPoolPtr</a> = typedef <a class="el" href="classyaclib_1_1util_1_1Ptr.html">util::Ptr</a>&lt;<a class="el" href="classyaclib_1_1IThreadPool.html">IThreadPool</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00041">41</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="a85c3cb3b321f85b6e96b47e50f6e0b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c3cb3b321f85b6e96b47e50f6e0b0d">&#9670;&nbsp;</a></span>IThreadPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#a85c3cb3b321f85b6e96b47e50f6e0b0d">yaclib::IThreadPtr</a> = typedef <a class="el" href="classyaclib_1_1IThread.html">IThread</a>*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__factory_8hpp_source.html#l00016">16</a> of file <a class="el" href="thread__factory_8hpp_source.html">thread_factory.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a37f2112670e904598949ee2d6f043254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f2112670e904598949ee2d6f043254">&#9670;&nbsp;</a></span>PolicyWhenAny</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceyaclib.html#a37f2112670e904598949ee2d6f043254">yaclib::PolicyWhenAny</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a37f2112670e904598949ee2d6f043254a928e284a9dd5356bc1ca5f82a38e47d9"></a>FirstError&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a37f2112670e904598949ee2d6f043254a49b8f9d972a16a3efaab2442f79bcacb"></a>LastError&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="when__any_8hpp_source.html#l00012">12</a> of file <a class="el" href="when__any_8hpp_source.html">when_any.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a60e27483f912682aad998898f42b775f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e27483f912682aad998898f42b775f">&#9670;&nbsp;</a></span>CurrentThreadPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyaclib_1_1IThreadPool.html">IThreadPool</a> * yaclib::CurrentThreadPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Thread local pointer to the ThreadPool that owns the current thread nullptr if no ThreadPool owns the thread </dd></dl>

<p class="definition">Definition at line <a class="el" href="src_2executor_2thread__pool_8cpp_source.html#l00261">261</a> of file <a class="el" href="src_2executor_2thread__pool_8cpp_source.html">thread_pool.cpp</a>.</p>

</div>
</div>
<a id="a9de6f83d739994cdb2ab9348060ccfe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de6f83d739994cdb2ab9348060ccfe0">&#9670;&nbsp;</a></span>MakeContract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structyaclib_1_1Contract.html">Contract</a>&lt; T &gt; yaclib::MakeContract </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates related future and promise. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structyaclib_1_1Contract.html" title="Describes channel with future and promise.">Contract</a> object with new future and promise </dd></dl>

<p class="definition">Definition at line <a class="el" href="promise__impl_8hpp_source.html#l00040">40</a> of file <a class="el" href="promise__impl_8hpp_source.html">promise_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="promise__impl_8hpp_source.html#l00014">yaclib::Promise&lt; T &gt;::MakeFuture()</a>.</p>

</div>
</div>
<a id="af57cab962d5a434a0e5bb954b4dc06b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57cab962d5a434a0e5bb954b4dc06b7">&#9670;&nbsp;</a></span>MakeFuture() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; void &gt; yaclib::MakeFuture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="future__impl_8cpp_source.html#l00007">7</a> of file <a class="el" href="future__impl_8cpp_source.html">future_impl.cpp</a>.</p>

<p class="reference">References <a class="el" href="result_8hpp_source.html#l00082">yaclib::util::Result&lt; T &gt;::Default()</a>.</p>

</div>
</div>
<a id="afd6a352774c58d4aab80fdb73961c00e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6a352774c58d4aab80fdb73961c00e">&#9670;&nbsp;</a></span>MakeFuture() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename T  = std::remove_reference_t&lt;V&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyaclib_1_1Future.html">Future</a>&lt;T&gt; yaclib::MakeFuture </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="future_8hpp_source.html#l00178">178</a> of file <a class="el" href="future_8hpp_source.html">future.hpp</a>.</p>

</div>
</div>
<a id="abbc0efb205f36bd5fd244f1991658c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc0efb205f36bd5fd244f1991658c0b">&#9670;&nbsp;</a></span>MakeFuture() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!std::is_same_v&lt;T, std::remove_reference_t&lt;V&gt; &gt;, <a class="el" href="classyaclib_1_1Future.html">Future</a>&lt;T&gt; &gt; yaclib::MakeFuture </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="future_8hpp_source.html#l00183">183</a> of file <a class="el" href="future_8hpp_source.html">future.hpp</a>.</p>

</div>
</div>
<a id="ab247a06a303af6a2234d2247eb0d1e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab247a06a303af6a2234d2247eb0d1e55">&#9670;&nbsp;</a></span>MakeInline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#a7231c27a288094bf6017cda8cb4e2f7a">IExecutorPtr</a> yaclib::MakeInline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get <a class="el" href="classyaclib_1_1Inline.html">Inline</a> executor singleton object. </p>
<p>This executor immediately executes given Callable object in the same OS thread without any overhead. </p><dl class="section note"><dt>Note</dt><dd>This object is useful as safe default executor value. See example.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> task = [] { <span class="keywordflow">return</span> 0; };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Without inline executor:</span></div>
<div class="line"><a class="code" href="namespaceyaclib.html#a7231c27a288094bf6017cda8cb4e2f7a">IExecutorPtr</a> executor = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="keywordflow">if</span> (...) {</div>
<div class="line">  executor = <a class="code" href="namespaceyaclib.html#a9f76f7768e2f42ea4d8cc13180a62f0c">MakeThreadPool</a>(4);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (executor) {</div>
<div class="line">  executor-&gt;Execute(task);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  a();</div>
<div class="line">}</div>
<div class="line"><span class="comment">// With inline executor:</span></div>
<div class="line"><a class="code" href="namespaceyaclib.html#a7231c27a288094bf6017cda8cb4e2f7a">IExecutorPtr</a> executor{MakeInlineExecutor()};</div>
<div class="line">...</div>
<div class="line">executor-&gt;<a class="code" href="classyaclib_1_1IExecutor.html#a96f8c92cf9781697431a40fc747be1ba">Execute</a>(task);</div>
<div class="ttc" id="aclassyaclib_1_1IExecutor_html_a96f8c92cf9781697431a40fc747be1ba"><div class="ttname"><a href="classyaclib_1_1IExecutor.html#a96f8c92cf9781697431a40fc747be1ba">yaclib::IExecutor::Execute</a></div><div class="ttdeci">bool Execute(Functor &amp;&amp;functor)</div><div class="ttdoc">Execute given functor for details.</div><div class="ttdef"><b>Definition:</b> <a href="executor_8hpp_source.html#l00036">executor.hpp:36</a></div></div>
<div class="ttc" id="anamespaceyaclib_html_a7231c27a288094bf6017cda8cb4e2f7a"><div class="ttname"><a href="namespaceyaclib.html#a7231c27a288094bf6017cda8cb4e2f7a">yaclib::IExecutorPtr</a></div><div class="ttdeci">util::Ptr&lt; IExecutor &gt; IExecutorPtr</div><div class="ttdef"><b>Definition:</b> <a href="executor_8hpp_source.html#l00053">executor.hpp:53</a></div></div>
<div class="ttc" id="anamespaceyaclib_html_a9f76f7768e2f42ea4d8cc13180a62f0c"><div class="ttname"><a href="namespaceyaclib.html#a9f76f7768e2f42ea4d8cc13180a62f0c">yaclib::MakeThreadPool</a></div><div class="ttdeci">IThreadPoolPtr MakeThreadPool(size_t threads=std::thread::hardware_concurrency(), IThreadFactoryPtr tf=MakeThreadFactory())</div><div class="ttdoc">Create new ThreadPool object.</div><div class="ttdef"><b>Definition:</b> <a href="src_2executor_2thread__pool_8cpp_source.html#l00265">thread_pool.cpp:265</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="inline_8cpp_source.html#l00022">22</a> of file <a class="el" href="inline_8cpp_source.html">inline.cpp</a>.</p>

</div>
</div>
<a id="addd98a07638a00a30d55a2bd8527f197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd98a07638a00a30d55a2bd8527f197">&#9670;&nbsp;</a></span>MakeSerial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#a7231c27a288094bf6017cda8cb4e2f7a">IExecutorPtr</a> yaclib::MakeSerial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyaclib.html#a7231c27a288094bf6017cda8cb4e2f7a">IExecutorPtr</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serial is the asynchronous analogue of a mutex. </p>
<p>It guarantees that the tasks scheduled for it will be executed strictly sequentially. Serial itself does not have its own threads, it decorates another executor and uses it to run its tasks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>executor to decorate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to new Serial instance </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="serial_8cpp-example.html#a2">serial.cpp</a>, and <a class="el" href="simple_8cpp-example.html#a9">simple.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="src_2executor_2serial_8cpp_source.html#l00073">73</a> of file <a class="el" href="src_2executor_2serial_8cpp_source.html">serial.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="test_2example_2executor_2serial_8cpp_source.html#l00015">TEST()</a>.</p>

</div>
</div>
<a id="a34239f1ca3ed395ed5d22993d751c96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34239f1ca3ed395ed5d22993d751c96a">&#9670;&nbsp;</a></span>MakeThreadFactory() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#a2af9e084c41dda4eb49c4f7d96b96fdd">IThreadFactoryPtr</a> yaclib::MakeThreadFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyaclib.html#a2af9e084c41dda4eb49c4f7d96b96fdd">IThreadFactoryPtr</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__factory_8cpp_source.html#l00348">348</a> of file <a class="el" href="thread__factory_8cpp_source.html">thread_factory.cpp</a>.</p>

</div>
</div>
<a id="a79929f0e9d8377b4491a430042fcd808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79929f0e9d8377b4491a430042fcd808">&#9670;&nbsp;</a></span>MakeThreadFactory() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#a2af9e084c41dda4eb49c4f7d96b96fdd">IThreadFactoryPtr</a> yaclib::MakeThreadFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyaclib.html#a2af9e084c41dda4eb49c4f7d96b96fdd">IThreadFactoryPtr</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__factory_8cpp_source.html#l00352">352</a> of file <a class="el" href="thread__factory_8cpp_source.html">thread_factory.cpp</a>.</p>

</div>
</div>
<a id="aac9f5858b675d032b6d23b156f9769d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9f5858b675d032b6d23b156f9769d3">&#9670;&nbsp;</a></span>MakeThreadFactory() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#a2af9e084c41dda4eb49c4f7d96b96fdd">IThreadFactoryPtr</a> yaclib::MakeThreadFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyaclib.html#a2af9e084c41dda4eb49c4f7d96b96fdd">IThreadFactoryPtr</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyaclib_1_1util.html#ae7fef7e414f78f74b8ab2cf37069dee0">util::IFuncPtr</a>&#160;</td>
          <td class="paramname"><em>acquire</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyaclib_1_1util.html#ae7fef7e414f78f74b8ab2cf37069dee0">util::IFuncPtr</a>&#160;</td>
          <td class="paramname"><em>release</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__factory_8cpp_source.html#l00356">356</a> of file <a class="el" href="thread__factory_8cpp_source.html">thread_factory.cpp</a>.</p>

</div>
</div>
<a id="acac43f3130e0930be550b31fccdb5f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac43f3130e0930be550b31fccdb5f72">&#9670;&nbsp;</a></span>MakeThreadFactory() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#a2af9e084c41dda4eb49c4f7d96b96fdd">IThreadFactoryPtr</a> yaclib::MakeThreadFactory </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cache</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__factory_8cpp_source.html#l00340">340</a> of file <a class="el" href="thread__factory_8cpp_source.html">thread_factory.cpp</a>.</p>

</div>
</div>
<a id="a9f76f7768e2f42ea4d8cc13180a62f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f76f7768e2f42ea4d8cc13180a62f0c">&#9670;&nbsp;</a></span>MakeThreadPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#a1c53b61d7ba175a9a056a249735148f5">IThreadPoolPtr</a> yaclib::MakeThreadPool </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>threads</em> = <code>std::thread::hardware_concurrency()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyaclib.html#a2af9e084c41dda4eb49c4f7d96b96fdd">IThreadFactoryPtr</a>&#160;</td>
          <td class="paramname"><em>tf</em> = <code><a class="el" href="namespaceyaclib.html#acac43f3130e0930be550b31fccdb5f72">MakeThreadFactory</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create new ThreadPool object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threads</td><td>the number of threads to create for this ThreadPool </td></tr>
    <tr><td class="paramname">f</td><td>thread factory to use for thread creation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classyaclib_1_1IThreadFactory.html">IThreadFactory</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>intrusive pointer to the new ThreadPool </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="serial_8cpp-example.html#a1">serial.cpp</a>, <a class="el" href="simple_8cpp-example.html#a2">simple.cpp</a>, <a class="el" href="thread_pool_8cpp-example.html#a1">thread_pool.cpp</a>, <a class="el" href="when_all_8cpp-example.html#a2">when_all.cpp</a>, and <a class="el" href="when_any_8cpp-example.html#a2">when_any.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="src_2executor_2thread__pool_8cpp_source.html#l00265">265</a> of file <a class="el" href="src_2executor_2thread__pool_8cpp_source.html">thread_pool.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="test_2example_2executor_2serial_8cpp_source.html#l00015">TEST()</a>.</p>

</div>
</div>
<a id="a5fbf001b64fb8536699a934ef2da6706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbf001b64fb8536699a934ef2da6706">&#9670;&nbsp;</a></span>Run()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto yaclib::Run </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceyaclib.html#a7231c27a288094bf6017cda8cb4e2f7a">IExecutorPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute Callable functor via executor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>executor to be used to execute f and saved as callback executor for return <a class="el" href="classyaclib_1_1Future.html">Future</a> </td></tr>
    <tr><td class="paramname">f</td><td>functor to execute </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classyaclib_1_1Future.html">Future</a> corresponding f return value </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="simple_8cpp-example.html#a3">simple.cpp</a>, <a class="el" href="when_all_8cpp-example.html#a3">when_all.cpp</a>, and <a class="el" href="when_any_8cpp-example.html#a3">when_any.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="run_8hpp_source.html#l00018">18</a> of file <a class="el" href="run_8hpp_source.html">run.hpp</a>.</p>

<p class="reference">References <a class="el" href="executor_8hpp_source.html#l00036">yaclib::IExecutor::Execute()</a>, <a class="el" href="classyaclib_1_1IExecutor.html#adad1d029ecaf5a6291401978d4c38802a0125cf5f3ca38b312ca5d3b511c45a13">yaclib::IExecutor::Inline</a>, and <a class="el" href="classyaclib_1_1IExecutor.html#ad4e7a10fd641ca5fcf91d2aeb96da822">yaclib::IExecutor::Tag()</a>.</p>

<p class="reference">Referenced by <a class="el" href="simple_8cpp_source.html#l00113">CalculatorService::Double()</a>, <a class="el" href="simple_8cpp_source.html#l00107">CalculatorService::Increment()</a>, and <a class="el" href="simple_8cpp_source.html#l00030">TEST()</a>.</p>

</div>
</div>
<a id="a37a6bb22f7fab7bbca62739964ed895d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37a6bb22f7fab7bbca62739964ed895d">&#9670;&nbsp;</a></span>Wait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Futures&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void yaclib::Wait </td>
          <td>(</td>
          <td class="paramtype">Futures &amp;&amp;...&#160;</td>
          <td class="paramname"><em>fs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until Ready becomes true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>one or more futures to wait </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="wait_8hpp_source.html#l00013">13</a> of file <a class="el" href="wait_8hpp_source.html">wait.hpp</a>.</p>

<p class="reference">References <a class="el" href="wait__impl_8hpp_source.html#l00013">yaclib::detail::Wait()</a>.</p>

</div>
</div>
<a id="a3a6a79b363eabace9eaa99eb665f4fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a6a79b363eabace9eaa99eb665f4fc1">&#9670;&nbsp;</a></span>WaitFor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period , typename... Futures&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::WaitFor </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout_duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Futures &amp;&amp;...&#160;</td>
          <td class="paramname"><em>fs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until the specified timeout duration has elapsed or Ready becomes true. </p>
<p>The behavior is undefined if Valid is false before the call to this function. This function may block for longer than timeout_duration due to scheduling or resource contention delays. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_duration</td><td>maximum duration to block for </td></tr>
    <tr><td class="paramname">fs</td><td>futures to wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of Ready upon exiting </dd></dl>

<p class="definition">Definition at line <a class="el" href="wait__for_8hpp_source.html#l00017">17</a> of file <a class="el" href="wait__for_8hpp_source.html">wait_for.hpp</a>.</p>

<p class="reference">References <a class="el" href="wait__impl_8hpp_source.html#l00013">yaclib::detail::Wait()</a>.</p>

</div>
</div>
<a id="ab93d083816b0da430408ad4ff34d55a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93d083816b0da430408ad4ff34d55a4">&#9670;&nbsp;</a></span>WaitUntil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Clock , typename Duration , typename... Futures&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::WaitUntil </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Futures &amp;&amp;...&#160;</td>
          <td class="paramname"><em>fs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until specified time has been reached or Ready becomes true. </p>
<p>The behavior is undefined if Valid is false before the call to this function. This function may block for longer than until after timeout_time has been reached due to scheduling or resource contention delays. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_time</td><td>maximum time point to block until </td></tr>
    <tr><td class="paramname">fs</td><td>futures to wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of Ready upon exiting </dd></dl>

<p class="definition">Definition at line <a class="el" href="wait__until_8hpp_source.html#l00018">18</a> of file <a class="el" href="wait__until_8hpp_source.html">wait_until.hpp</a>.</p>

<p class="reference">References <a class="el" href="wait__impl_8hpp_source.html#l00013">yaclib::detail::Wait()</a>.</p>

</div>
</div>
<a id="a0d5e7b2d43671c14b7be0241a13d358f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d5e7b2d43671c14b7be0241a13d358f">&#9670;&nbsp;</a></span>WhenAll() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Fs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto yaclib::WhenAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="classyaclib_1_1Future.html">Future</a> which will be ready when all futures are ready. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of all passed futures </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head,tail</td><td>one or more futures to combine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classyaclib_1_1Future.html" title="Provides a mechanism to access the result of async operations.">Future</a>&lt;array&lt;T&gt;&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="when__all_8hpp_source.html#l00153">153</a> of file <a class="el" href="when__all_8hpp_source.html">when_all.hpp</a>.</p>

<p class="reference">References <a class="el" href="when__all_8hpp_source.html#l00102">yaclib::detail::WhenAllImpl()</a>.</p>

</div>
</div>
<a id="ab05755a6f4937c6e11bcf41e962efe76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05755a6f4937c6e11bcf41e962efe76">&#9670;&nbsp;</a></span>WhenAll() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto yaclib::WhenAll </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="classyaclib_1_1Future.html">Future</a> which will be ready when all futures are ready. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">It</td><td>type of passed iterator </td></tr>
    <tr><td class="paramname">T</td><td>type of all passed futures </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,end</td><td>the range of futures to combine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classyaclib_1_1Future.html" title="Provides a mechanism to access the result of async operations.">Future</a>&lt;vector&lt;T&gt;&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="when__all_8hpp_source.html#l00140">140</a> of file <a class="el" href="when__all_8hpp_source.html">when_all.hpp</a>.</p>

<p class="reference">References <a class="el" href="type__traits_8hpp_source.html#l00069">yaclib::util::IsFutureV</a>, and <a class="el" href="when__all_8hpp_source.html#l00121">WhenAll()</a>.</p>

</div>
</div>
<a id="a3d49a2608a8a33787c5a3cea5e48faa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d49a2608a8a33787c5a3cea5e48faa9">&#9670;&nbsp;</a></span>WhenAll() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It , typename T  = util::detail::FutureValueT&lt;typename std::iterator_traits&lt;It&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto yaclib::WhenAll </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="classyaclib_1_1Future.html">Future</a> which will be ready when all futures are ready. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">It</td><td>type of passed iterator </td></tr>
    <tr><td class="paramname">T</td><td>type of all passed futures </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,size</td><td>the range of futures to combine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classyaclib_1_1Future.html" title="Provides a mechanism to access the result of async operations.">Future</a>&lt;vector&lt;T&gt;&gt; </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="when_all_8cpp-example.html#a1">when_all.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="when__all_8hpp_source.html#l00121">121</a> of file <a class="el" href="when__all_8hpp_source.html">when_all.hpp</a>.</p>

<p class="reference">References <a class="el" href="when__all_8hpp_source.html#l00037">yaclib::detail::AllCombinator&lt; T, N, IsArray, FutureValue &gt;::Make()</a>.</p>

<p class="reference">Referenced by <a class="el" href="when__all_8cpp_source.html#l00019">TEST()</a>, and <a class="el" href="when__all_8hpp_source.html#l00140">WhenAll()</a>.</p>

</div>
</div>
<a id="a7b5363dd6455722e183c0ef83bc706b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5363dd6455722e183c0ef83bc706b6">&#9670;&nbsp;</a></span>WhenAny() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PolicyWhenAny P = PolicyWhenAny::FirstError, typename T , typename... Fs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto yaclib::WhenAny </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="classyaclib_1_1Future.html">Future</a> that is ready when any of futures is ready. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">P</td><td>policy WhenAny errors </td></tr>
    <tr><td class="paramname">T</td><td>type of all passed futures </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head,tail</td><td>one or more futures to combine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;T&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="when__any_8hpp_source.html#l00177">177</a> of file <a class="el" href="when__any_8hpp_source.html">when_any.hpp</a>.</p>

<p class="reference">References <a class="el" href="when__any_8hpp_source.html#l00057">yaclib::detail::AnyCombinator&lt; T, P &gt;::Make()</a>.</p>

</div>
</div>
<a id="a8888500725b47abf63d9a187311e5501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8888500725b47abf63d9a187311e5501">&#9670;&nbsp;</a></span>WhenAny() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PolicyWhenAny P = PolicyWhenAny::FirstError, typename It , typename T  = util::detail::FutureValueT&lt;typename std::iterator_traits&lt;It&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto yaclib::WhenAny </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="classyaclib_1_1Future.html">Future</a> that is ready when any of futures is ready. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">P</td><td>policy WhenAny errors </td></tr>
    <tr><td class="paramname">It</td><td>type of passed iterator </td></tr>
    <tr><td class="paramname">T</td><td>type of all passed futures </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,end</td><td>the range of futures to combine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;T&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="when__any_8hpp_source.html#l00164">164</a> of file <a class="el" href="when__any_8hpp_source.html">when_any.hpp</a>.</p>

<p class="reference">References <a class="el" href="when__any_8hpp_source.html#l00106">yaclib::detail::WhenAnyImpl()</a>.</p>

</div>
</div>
<a id="aeefa36ba9f61dcc44b7b4b7b9b137eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeefa36ba9f61dcc44b7b4b7b9b137eb7">&#9670;&nbsp;</a></span>WhenAny() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PolicyWhenAny P = PolicyWhenAny::FirstError, typename It , typename T  = util::detail::FutureValueT&lt;typename std::iterator_traits&lt;It&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto yaclib::WhenAny </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="classyaclib_1_1Future.html">Future</a> that is ready when any of futures is ready. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">P</td><td>policy WhenAny errors </td></tr>
    <tr><td class="paramname">It</td><td>type of passed iterator </td></tr>
    <tr><td class="paramname">T</td><td>type of all passed futures </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,size</td><td>the range of futures to combine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;T&gt; </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="when_any_8cpp-example.html#a1">when_any.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="when__any_8hpp_source.html#l00149">149</a> of file <a class="el" href="when__any_8hpp_source.html">when_any.hpp</a>.</p>

<p class="reference">References <a class="el" href="when__any_8hpp_source.html#l00106">yaclib::detail::WhenAnyImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="when__any_8cpp_source.html#l00019">TEST()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceyaclib.html">yaclib</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
<script type="text/javascript">
  $(document).ready(function(){
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
  })
</script>
</body>
</html>
